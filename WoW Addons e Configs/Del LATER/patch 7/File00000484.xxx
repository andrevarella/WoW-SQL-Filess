-- faction
_PLAYER_FACTION_GROUP = { [0] = "Horde", [1] = "Alliance", Horde = 0, Alliance = 1 };

_CLASS_SORT_ORDER = {
	[1] = {1, "WARRIOR"},
	[2] = {2, "PALADIN"},
	[3] = {4, "HUNTER"},
	[4] = {8, "ROGUE"},
	[5] = {16, "PRIEST"},
	[6] = {32, "DEATHKNIGHT"},
	[7] = {64, "SHAMAN"},
	[8] = {128, "MAGE"},
	[9] = {256, "WARLOCK"},
	[10] = {1024, "DRUID"},
};

_CLASS_DATA_LOCALIZATION = {};

do
	for index, classData in pairs(_CLASS_SORT_ORDER) do
		local keyMale = _G["SHARED_"..classData[2].."_MALE"];
		local keyFemale = _G["SHARED_"..classData[2].."_FEMALE"];

		classData[3] = index;
		classData[4] = keyMale;
		classData[5] = keyFemale;

		_CLASS_DATA_LOCALIZATION[keyMale] = classData;
		_CLASS_DATA_LOCALIZATION[keyFemale] = classData;
	end
end

-- table.lockTable(_CLASS_SORT_ORDER)

_CHARACTER_RACES_INFO = {
	[RACE_HUMAN]			 = {raceID = RACE_HUMAN, 			 clientFileString = "Human", 	raceName = "RACE_HUMAN", 			 raceNameFemale = "RACE_HUMAN_FEMALE", 				overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_ORC] 				 = {raceID = RACE_ORC, 				 clientFileString = "Orc", 		raceName = "RACE_ORC", 				 raceNameFemale = "RACE_ORC_FEMALE", 				overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_DWARF] 			 = {raceID = RACE_DWARF, 			 clientFileString = "Dwarf", 	raceName = "RACE_DWARF", 			 raceNameFemale = "RACE_DWARF_FEMALE", 				overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_NIGHTELF] 		 = {raceID = RACE_NIGHTELF, 		 clientFileString = "NightElf", raceName = "RACE_NIGHTELF", 		 raceNameFemale = "RACE_NIGHTELF_FEMALE", 			overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_SCOURGE] 			 = {raceID = RACE_SCOURGE, 			 clientFileString = "Scourge", 	raceName = "RACE_SCOURGE", 			 raceNameFemale = "RACE_SCOURGE_FEMALE", 			overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_TAUREN] 			 = {raceID = RACE_TAUREN, 			 clientFileString = "Tauren", 	raceName = "RACE_TAUREN", 			 raceNameFemale = "RACE_TAUREN_FEMALE", 			overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_GNOME] 			 = {raceID = RACE_GNOME, 			 clientFileString = "Gnome", 	raceName = "RACE_GNOME", 			 raceNameFemale = "RACE_GNOME_FEMALE", 				overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_TROLL] 			 = {raceID = RACE_TROLL, 			 clientFileString = "Troll", 	raceName = "RACE_TROLL", 			 raceNameFemale = "RACE_TROLL_FEMALE", 				overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_BLOODELF] 		 = {raceID = RACE_BLOODELF, 		 clientFileString = "BloodElf", raceName = "RACE_BLOODELF", 		 raceNameFemale = "RACE_BLOODELF_FEMALE", 			overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_DRAENEI] 			 = {raceID = RACE_DRAENEI, 			 clientFileString = "Draenei", 	raceName = "RACE_DRAENEI", 			 raceNameFemale = "RACE_DRAENEI_FEMALE", 			overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	
	[RACE_HUMAN_CREATURE] 	 = {raceID = RACE_HUMAN_CREATURE, 	 clientFileString = "Human", 	raceName = "RACE_HUMAN_CREATURE",	 raceNameFemale = "RACE_HUMAN_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_ORC_CREATURE] 	 = {raceID = RACE_ORC_CREATURE, 	 clientFileString = "Orc", 		raceName = "RACE_ORC_CREATURE", 	 raceNameFemale = "RACE_ORC_CREATURE_FEMALE", 		overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_DWARF_CREATURE] 	 = {raceID = RACE_DWARF_CREATURE, 	 clientFileString = "Dwarf", 	raceName = "RACE_DWARF_CREATURE", 	 raceNameFemale = "RACE_DWARF_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_NIGHTELF_CREATURE] = {raceID = RACE_NIGHTELF_CREATURE, clientFileString = "NightElf", raceName = "RACE_NIGHTELF_CREATURE", raceNameFemale = "RACE_NIGHTELF_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_SCOURGE_CREATURE]  = {raceID = RACE_SCOURGE_CREATURE,  clientFileString = "Scourge", 	raceName = "RACE_SCOURGE_CREATURE",  raceNameFemale = "RACE_SCOURGE_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_TAUREN_CREATURE] 	 = {raceID = RACE_TAUREN_CREATURE, 	 clientFileString = "Tauren", 	raceName = "RACE_TAUREN_CREATURE", 	 raceNameFemale = "RACE_TAUREN_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_GNOME_CREATURE] 	 = {raceID = RACE_GNOME_CREATURE, 	 clientFileString = "Gnome", 	raceName = "RACE_GNOME_CREATURE",	 raceNameFemale = "RACE_GNOME_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
	[RACE_TROLL_CREATURE] 	 = {raceID = RACE_TROLL_CREATURE, 	 clientFileString = "Troll", 	raceName = "RACE_TROLL_CREATURE",	 raceNameFemale = "RACE_TROLL_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_BLOODELF_CREATURE] = {raceID = RACE_BLOODELF_CREATURE, clientFileString = "BloodElf", raceName = "RACE_BLOODELF_CREATURE", raceNameFemale = "RACE_BLOODELF_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Horde},
	[RACE_DRAENEI_CREATURE]  = {raceID = RACE_DRAENEI_CREATURE,  clientFileString = "Draenei", 	raceName = "RACE_DRAENEI_CREATURE",	 raceNameFemale = "RACE_DRAENEI_CREATURE_FEMALE", 	overrideRaceName = nil, overrideRaceNameFemale = nil, factionID = _PLAYER_FACTION_GROUP.Alliance},
};

_CHARACTER_RACES_INFO_LOCALIZATION = {};
for _, data in pairs(_CHARACTER_RACES_INFO) do
	if data.raceName and not string.find(data.raceName, "_CREATURE") then
		_CHARACTER_RACES_INFO_LOCALIZATION[_G[data.raceName]] = data
	end
	if data.raceNameFemale then
		_CHARACTER_RACES_INFO_LOCALIZATION[_G[data.raceNameFemale]] = data
	end
end

local CONST_ATLAS_WIDTH			= 1
local CONST_ATLAS_HEIGHT		= 2
local CONST_ATLAS_LEFT			= 3
local CONST_ATLAS_RIGHT			= 4
local CONST_ATLAS_TOP			= 5
local CONST_ATLAS_BOTTOM		= 6
local CONST_ATLAS_TILESHORIZ	= 7
local CONST_ATLAS_TILESVERT		= 8
local CONST_ATLAS_TEXTUREPATH	= 9

AtlasStorage = {
	-- ["CharacterSelect-FactionIcon-Alliance"] = { 54, 54, 0.0234375, 0.3046875, 0.0234375, 0.3046875, false, false, "Interface/Glues/CharacterSelect/FactionIcons" },
	-- ["CharacterSelect-FactionIcon-Horde"] = { 54, 54, 0.3359375, 0.6171875, 0.0234375, 0.3046875, false, false, "Interface/Glues/CharacterSelect/FactionIcons" },
	-- ["CharacterSelect-FactionIcon-1"] = { 54, 54, 0.0234375, 0.3046875, 0.0234375, 0.3046875, false, false, "Interface/Glues/CharacterSelect/FactionIcons" },
	-- ["CharacterSelect-FactionIcon-0"] = { 54, 54, 0.3359375, 0.6171875, 0.0234375, 0.3046875, false, false, "Interface/Glues/CharacterSelect/FactionIcons" },
	["CharacterSelect-FactionIcon-1"] = { 42, 42, 0, 1, 0, 1, false, false, "Interface/FriendsFrame/PlusManz-Alliance" },
	["CharacterSelect-FactionIcon-0"] = { 42, 42, 0, 1, 0, 1, false, false, "Interface/FriendsFrame/PlusManz-Horde" },
};

function math.Rounded( num, idp )
	local mult = 10 ^ ( idp or 0 );
	return math.floor( num * mult + 0.5 ) / mult;
end

function WrapTextInClassColorCode(text, colorHexString)
	return ("|c%s%s|r"):format(colorHexString, text);
end

ClassColorMixin = {};
function CreateClassColor(r, g, b, a)
	local color = CreateFromMixins(ClassColorMixin);
	color:OnLoad(r, g, b, a);
	return color;
end

function ClassColorMixin:OnLoad(r, g, b, a)
	self:SetRGBA(r, g, b, a);
end

function ClassColorMixin:GetRGBAsBytes()
	return math.Rounded(self.r * 255), math.Rounded(self.g * 255), math.Rounded(self.b * 255)
end

function ClassColorMixin:SetRGBA(r, g, b, a)
	self.r = r;
	self.g = g;
	self.b = b;
	self.a = a;
end

function ClassColorMixin:GenerateHexColor()
	return ("ff%.2x%.2x%.2x"):format(self:GetRGBAsBytes())
end

function ClassColorMixin:WrapTextInClassColorCode(text)
	return WrapTextInClassColorCode(text, self:GenerateHexColor())
end

local RAID_CLASS_COLORS = {
	["HUNTER"] = CreateClassColor(0.67, 0.83, 0.45),
	["WARLOCK"] = CreateClassColor(0.58, 0.51, 0.79),
	["PRIEST"] = CreateClassColor(1.0, 1.0, 1.0),
	["PALADIN"] = CreateClassColor(0.96, 0.55, 0.73),
	["MAGE"] = CreateClassColor(0.41, 0.8, 0.94),
	["ROGUE"] = CreateClassColor(1.0, 0.96, 0.41),
	["DRUID"] = CreateClassColor(1.0, 0.49, 0.04),
	["SHAMAN"] = CreateClassColor(0.0, 0.44, 0.87),
	["WARRIOR"] = CreateClassColor(0.78, 0.61, 0.43),
	["DEATHKNIGHT"] = CreateClassColor(0.77, 0.12 , 0.23),
};

-- for _, v in pairs(RAID_CLASS_COLORS) do
	-- v.colorStr = v:GenerateHexColor()
-- end

-- function GetClassColor(classFilename)
	-- local color = RAID_CLASS_COLORS[classFilename]
	-- if color then
		-- return color.r, color.g, color.b, color.colorStr
	-- end

	-- return 1, 1, 1, "ffffffff";
-- end

function GetClassColorObj(classFilename)
	return RAID_CLASS_COLORS[classFilename]
end

C_CreatureInfo = {};

function C_CreatureInfo.GetClassInfo( class )
	assert(class, "C_CreatureInfo.GetClassInfo: class must be specified.");

	local classData = _CLASS_SORT_ORDER[class] or _CLASS_DATA_LOCALIZATION[class];
	assert(classData, "C_CreatureInfo.GetClassInfo: class ["..class.."] not found.");

	local ClassInfo = {};

	ClassInfo.classFile 	= classData[2];
	ClassInfo.className 	= classData[4];
	ClassInfo.classID 		= classData[3];
	ClassInfo.classFlag 	= classData[1];
	ClassInfo.localizeName 	= {
		male = classData[4],
		female = classData[5]
	};

	return ClassInfo;
end

function C_CreatureInfo.GetRaceInfo( race )
	assert(race, "C_CreatureInfo.GetRaceInfo: race must be specified.")

	local raceData = _CHARACTER_RACES_INFO[race] or _CHARACTER_RACES_INFO_LOCALIZATION[race];
	assert(raceData, "C_CreatureInfo.GetRaceInfo: race ["..race.."] not found.");

	if not raceData then
		raceData = {
			raceName = "RACE_HUMAN",
			clientFileString = "Human",
			raceID = 1,
			factionID = 1
		};
	end

	local RaceInfo  = {};

	RaceInfo.raceName 			= _G[raceData.raceName];
	RaceInfo.clientFileString 	= raceData.clientFileString;
	RaceInfo.raceID 			= raceData.raceID;
	RaceInfo.localizeName 		= {
		male = _G[raceData.overrideRaceName] or _G[raceData.raceName],
		female = _G[raceData.overrideRaceNameFemale] or _G[raceData.raceNameFemale]
	};

	return RaceInfo;
end

function C_CreatureInfo.GetFactionInfo( race )
	assert(race, "C_CreatureInfo.GetFactionInfo: race must be specified.");

	local raceData = _CHARACTER_RACES_INFO[race] or _CHARACTER_RACES_INFO_LOCALIZATION[race];
	assert(raceData, "C_CreatureInfo.GetFactionInfo: race ["..race.."] not found.");

	if not raceData then
		raceData = {
			raceName = "RACE_HUMAN",
			clientFileString = "Human",
			raceID = 1,
			factionID = 1
		};
	end

	local FactionInfo = {};
	local factionTag  = _PLAYER_FACTION_GROUP[raceData.factionID];

	FactionInfo.name 		= _G["FACTION_"..string.upper(factionTag)];
	FactionInfo.groupTag 	= factionTag;
	FactionInfo.factionID 	= raceData.factionID;

	return FactionInfo;
end

-- methods;
local texture;
local frame = getmetatable(CreateFrame("Frame"));
local frame_data = {CreateFrame("Frame"), CreateFrame("Button")};

local function initSubFrame()
	for _, data in pairs(frame_data) do
		texture = getmetatable(data:CreateTexture());
	end
end
initSubFrame();

local function Method_SetShown(self, ...)
	if ... then
		self:Show();
	else
		self:Hide();
	end
end

function texture.__index:SetShown(...)
	Method_SetShown(self, ...);
end

local function Method_SetAtlas( self, atlasName, useAtlasSize, filterMode )
	assert(self, "Method_SetAtlas: not found object");
	assert(atlasName, "Method_SetAtlas: AtlasName must be specified");
	assert(AtlasStorage[atlasName], "Method_SetAtlas: Atlas named "..atlasName.." does not exist");

	local atlas = AtlasStorage[atlasName];
	self:SetTexture(atlas[CONST_ATLAS_TEXTUREPATH] or "", atlas[CONST_ATLAS_TILESHORIZ], atlas[CONST_ATLAS_TILESVERT]);

	if useAtlasSize then
		self:SetWidth(atlas[CONST_ATLAS_WIDTH]);
		self:SetHeight(atlas[CONST_ATLAS_HEIGHT]);
	end

	self:SetTexCoord(atlas[CONST_ATLAS_LEFT], atlas[CONST_ATLAS_RIGHT], atlas[CONST_ATLAS_TOP], atlas[CONST_ATLAS_BOTTOM]);
	self:SetHorizTile(atlas[CONST_ATLAS_TILESHORIZ]);
	self:SetVertTile(atlas[CONST_ATLAS_TILESVERT]);
end

function texture.__index:SetGlueAtlas( atlasName, useAtlasSize, filterMode )
	Method_SetAtlas( self, atlasName, useAtlasSize, filterMode );
end

function SetClampedTextureRotation(texture, rotationDegrees)
	if (rotationDegrees ~= 0 and rotationDegrees ~= 90 and rotationDegrees ~= 180 and rotationDegrees ~= 270) then
		error("SetRotation: rotationDegrees must be 0, 90, 180, or 270");
		return;
	end

	if not (texture.rotationDegrees) then
		texture.origTexCoords = {texture:GetTexCoord()};
		texture.origWidth = texture:GetWidth();
		texture.origHeight = texture:GetHeight();
	end

	if (texture.rotationDegrees == rotationDegrees) then
		return;
	end

	texture.rotationDegrees = rotationDegrees;

	if (rotationDegrees == 0 or rotationDegrees == 180) then
		texture:SetWidth(texture.origWidth);
		texture:SetHeight(texture.origHeight);
	else
		texture:SetWidth(texture.origHeight);
		texture:SetHeight(texture.origWidth);
	end

	if (rotationDegrees == 0) then
		texture:SetTexCoord( texture.origTexCoords[1], texture.origTexCoords[2],
											texture.origTexCoords[3], texture.origTexCoords[4],
											texture.origTexCoords[5], texture.origTexCoords[6],
											texture.origTexCoords[7], texture.origTexCoords[8] );
	elseif (rotationDegrees == 90) then
		texture:SetTexCoord( texture.origTexCoords[3], texture.origTexCoords[4],
											texture.origTexCoords[7], texture.origTexCoords[8],
											texture.origTexCoords[1], texture.origTexCoords[2],
											texture.origTexCoords[5], texture.origTexCoords[6] );
	elseif (rotationDegrees == 180) then
		texture:SetTexCoord( texture.origTexCoords[7], texture.origTexCoords[8],
											texture.origTexCoords[5], texture.origTexCoords[6],
											texture.origTexCoords[3], texture.origTexCoords[4],
											texture.origTexCoords[1], texture.origTexCoords[2] );
	elseif (rotationDegrees == 270) then
		texture:SetTexCoord( texture.origTexCoords[5], texture.origTexCoords[6],
											texture.origTexCoords[1], texture.origTexCoords[2],
											texture.origTexCoords[7], texture.origTexCoords[8],
											texture.origTexCoords[3], texture.origTexCoords[4] );
	end
end